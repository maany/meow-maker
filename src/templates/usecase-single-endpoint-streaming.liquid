import { injectable } from "inversify";
import { BaseSingleEndpointStreamingUseCase } from "{{imports.cats}}/usecase"
import { AuthenticatedRequestModel } from "{{imports.cats}}/usecase-models";

import { {{feature.CamelCase}}Error, {{feature.CamelCase}}Request, {{feature.CamelCase}}Response } from "{{ imports.usecase_models }}/{{feature.kebab_case}}-usecase-models";
import { {{feature.CamelCase}}InputPort, type {{ feature.CamelCase }}OutputPort } from "{{ imports.primary_ports }}/{{feature.kebab_case}}-ports";
import {{ feature.CamelCase  }}Presenter from {{imports.presenter}}/{{ feature.kebab_case }}-presenter";
import { {{ viewModel.name }} } from "{{ viewModel.importPath }}";

import { {{gateway.dto.name}} } from "{{ gateway.dto.importPath }}";
import { {{ stream.dto.name }}} from "{{ stream.dto.importPath }}";
import type {{gateway.output_port.name}} from "{{ gateway.output_port.importPath }}";

@injectable()
export default class {{feature.CamelCase}}UseCase extends BaseSingleEndpointStreamingUseCase<AuthenticatedRequestModel<{{feature.CamelCase}}Request>, {{feature.CamelCase}}Response, {{feature.CamelCase}}Error, {{gateway.dto.name}}, {{ stream.dto.name }}, {{ viewModel.name }}> implements {{feature.CamelCase}}InputPort {
   
    constructor(
        protected readonly presenter: {{presenter}},
        private readonly gateway: {{gateway.output_port.name}},
    ) {
        super(presenter);
    }
    
    validateRequestModel(requestModel: AuthenticatedRequestModel<{{feature.CamelCase}}Request>): {{feature.CamelCase}}Error | undefined {
        return undefined;
    }

    async makeGatewayRequest(requestModel: AuthenticatedRequestModel<{{feature.CamelCase}}Request>): Promise<{{gateway.dto}}> {
        // TODO: pass parameters to gateway function
        const dto = await this.gateway.{{gateway.endpoint_fn}}(requestModel.rucioAuthToken);
        // TODO: convert to DTO and return DTO object
        return dto
    }
    handleGatewayError(error: {{gateway.dto}}): {{feature.CamelCase}}Error {
        return {
            error: error.error,
            message: error.message,
            status: error.status
        } as {{feature.CamelCase}}Error
    }

    processStreamedData(dto: {{stream.dto.name}}): { data: {{feature.CamelCase}}Response | {{feature.CamelCase}}Error; status: "success" | "error"; } {
        throw new Error("Method not implemented.");
    }
}