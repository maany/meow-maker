import { TConfig } from "./types";
import { existsSync } from "fs";
import { Liquid } from "liquidjs";
import { readFileSync, writeFileSync } from "fs";

export class BaseCompiledTemplate {
    protected engine: Liquid

    constructor(
        protected config: TConfig, 
        protected outputFilePath: string,
        protected templateName: string, 
    ) {
        const templateDir = `${__dirname}/../templates`
        const templatePath = `${templateDir}/${templateName}.liquid`

        if(!existsSync(templatePath)) throw new Error(`templatePath ${templatePath} does not exist`)
        this.engine = new Liquid({
            root: templateDir,
            extname: '.liquid'
        })
    } 

    execute(): {
        status: boolean,
        message: string
        content: string
        file: string

    } {
        try {
            console.log(`rendering template ${this.templateName}`)
            const content = this.engine.renderFileSync(this.templateName, this.config)
            console.log(`output file ${this.outputFilePath} created`)
            return {
                status: true,
                message: `output file ${this.outputFilePath} created`,
                content: content,
                file: this.outputFilePath
            }
        } catch(e: unknown) {
            console.log(`error rendering template ${this.templateName}`)
            console.log(e as Error)
            return {
                status: false,
                message: `error rendering template ${this.templateName}`,
                content: e as string,
                file: this.outputFilePath
            }
        }
    }
}

export abstract class BaseExistingFileAppender {
    constructor(
        protected config: TConfig,
        protected outputFilePath: string,
        protected write: boolean = false
    ) {
        if(!existsSync(outputFilePath)) {
            throw new Error(`outputFilePath ${this.outputFilePath} does not exist`)
        }
    }

    abstract importSection(): string | undefined

    abstract content(): string

    execute(): {
        status: boolean,
        message: string
        content: string
        importSection: string | undefined
        file: string
    } {
        if(!this.write) {
            console.log(`write flag is false, not writing to ${this.outputFilePath}`)
            return {
                status: false,
                message: `write flag is false, not writing to ${this.outputFilePath}`,
                content: this.content(),
                importSection: this.importSection(),
                file: this.outputFilePath
            }
        }
        const importSection = this.importSection()
        if(importSection === undefined) {
            console.log(`no import section for ${this.outputFilePath}`)
        } else {
            // Read the existing contents of the file
            const existingContents = readFileSync(this.outputFilePath, 'utf8');

            // Prepend the new contents to the existing contents
            const updatedContents = importSection + "\n" + existingContents;

            console.log(`writing to ${this.outputFilePath} importSection: \n ${importSection}`)
            // Write the updated contents back to the file
            try {
                writeFileSync(this.outputFilePath, updatedContents, 'utf8');
            } catch(e: unknown) {
                console.log(`error writing to ${this.outputFilePath}`)
                console.log(e as Error)
                return {
                    status: false,
                    message: `error writing to ${this.outputFilePath}`,
                    content: e as string,
                    importSection: importSection,
                    file: this.outputFilePath
                }
            }
        }

        const content = this.content()
        if(content === undefined) {
            console.log(`no content for ${this.outputFilePath}`)
            return {
                status: true,
                message: `no content for ${this.outputFilePath}`,
                content: "",
                importSection: importSection,
                file: this.outputFilePath
            }
        } else {
            // Read the existing contents of the file
            const existingContents = readFileSync(this.outputFilePath, 'utf8');
            
            // Append the new contents to the existing contents
            const updatedContents = existingContents + "\n"
            + "// auto-generated by meow-maker" + "\n" 
            + content;
            
            console.log(`writing to ${this.outputFilePath} contents: \n ${updatedContents}`)
            // Write the updated contents back to the file
            try {
                writeFileSync(this.outputFilePath, updatedContents, 'utf8');
                return {
                    status: true,
                    message: `output file ${this.outputFilePath} updated`,
                    content: content,
                    importSection: importSection,
                    file: this.outputFilePath
                }
            } catch(e: unknown) {
                console.log(`error writing to ${this.outputFilePath}`)
                console.log(e as Error)
                return {
                    status: false,
                    message: `error writing to ${this.outputFilePath}`,
                    content: e as string,
                    importSection: importSection,
                    file: this.outputFilePath
                }
            }
        }
    }
}




